package crypto

/*
Code Ownership:
Finn - Created all Functions
*/

import (
	"crypto/rsa"
	"encoding/hex"
	"encoding/json"
	"fmt"

	"github.com/herumi/bls-go-binary/bls"
)

// CTngIDs are URLS, but are abstracted to this type in case they are changed in the future.
type CTngID string

// Simple String conversion of an ID
func (id CTngID) String() string {
	return string(id)
}

// BLS IDs should be derived directly from the CTngID.
// This essentially maps every CTngID to a unique BLS ID.
// BLS IDs are used when generating bls private keys.
func (id CTngID) BlsID() *bls.ID {
	b := new(bls.ID)
	err := b.SetHexString(hex.EncodeToString([]byte(id)))
	// This shouldn't happen if IDs are being used appropriately, so I think a panic is warranted.
	if err != nil {
		panic(err)
	}
	return b
}

// The inverse of CTngID.BlsID(). Note that this is a function,
// while CTngID.BlsID() is a method.
func CTngIDfromBlsID(blsid *bls.ID) (CTngID, error) {
	id, err := hex.DecodeString(blsid.SerializeToHexStr())
	return CTngID(id), err
}

// The following types are neccessary for the sorting of CTng IDs and utilized by sort functions.
// Aggregated signatures generated by different entites should be identical when converted to a string.
// This can be done by sorting the list of IDs, making all ThresholdSig string representations identical.
type CTngIDs []CTngID

func (ids CTngIDs) Less(i, j int) bool {
	return string(ids[i]) < string(ids[j])
}
func (ids CTngIDs) Len() int {
	return len(ids)
}
func (ids CTngIDs) Swap(i, j int) {
	ids[i], ids[j] = ids[j], ids[i]
}

// Note that the following hash algorithms are not currently supported. This section of the code was
// derived from google/certificate-transparency-go, in clase many hash types should be supported in the future.
// HashAlgorithm enum from RFC 5246 s7.4.1.4.1.
type HashAlgorithm uint64

// HashAlgorithm constants from RFC 5246 s7.4.1.4.1.
const (
	None   HashAlgorithm = 0
	MD5    HashAlgorithm = 1
	SHA1   HashAlgorithm = 2
	SHA224 HashAlgorithm = 3
	SHA256 HashAlgorithm = 4
	SHA384 HashAlgorithm = 5
	SHA512 HashAlgorithm = 6
)

// String conversion method for hash types.
func (h HashAlgorithm) String() string {
	switch h {
	case None:
		return "None"
	case MD5:
		return "MD5"
	case SHA1:
		return "SHA1"
	case SHA224:
		return "SHA224"
	case SHA256:
		return "SHA256"
	case SHA384:
		return "SHA384"
	case SHA512:
		return "SHA512"
	default:
		return fmt.Sprintf("UNKNOWN(%d)", h)
	}
}

// Signature Fragments store the signer and the signature.
// This information can safely be sent, as it does not contain the private key.
// This information may be too much here: the gossiper should be able to deduce the
// signer(s) from the gossip object, as opposed to having it stored in the signature.
// Two possible refactors: remove the ID field altogether, or change it to a CTngID.
type SigFragment struct {
	Sign *bls.Sign
	ID   CTngID
}

// Convert a SigFragment to a string.
// Signatures need to be turned into strings to be stored in Gossip Objects.
// To convert back, use SigFragmentFromString().
func (s SigFragment) String() string {
	return fmt.Sprintf(`{"sign":"%s","id":"%s"}`, s.Sign.SerializeToHexStr(), s.ID.String())
}

// Convert a string signature to a SigFragment representation of that string.
func SigFragmentFromString(str string) (SigFragment, error) {
	s := new(SigFragment)
	s.Sign = new(bls.Sign)
	stringmap := make(map[string]string)
	err := json.Unmarshal([]byte(str), &stringmap)
	if err != nil {
		return *s, err
	}
	err = s.Sign.DeserializeHexStr(stringmap["sign"])
	if err != nil {
		return *s, err
	}
	s.ID = CTngID(stringmap["id"])
	return *s, err
}

type ThresholdSig struct {
	IDs  []CTngID // Users must know the list of IDs that created the theshold signature to verify.
	Sign *bls.Sign
}

func (t ThresholdSig) String() (string, error) {
	ids := make([]string, len(t.IDs))
	for i, id := range t.IDs {
		ids[i] = string(id)
	}
	idsStr, err := json.Marshal(ids)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf(`{"sign":"%s", "ids":%s}`, t.Sign.SerializeToHexStr(), idsStr), nil
}

func ThresholdSigFromString(str string) (ThresholdSig, error) {
	t := new(ThresholdSig)
	// Capture the fields in the struct generated below
	tstr := struct {
		Sign string
		IDs  []string
	}{}
	err := json.Unmarshal([]byte(str), &tstr)
	if err != nil {
		return *t, err
	}
	// Convert the IDS to CTngIDs
	t.IDs = make([]CTngID, len(tstr.IDs))
	for i, id := range tstr.IDs {
		t.IDs[i] = CTngID(id)
	}
	t.Sign = new(bls.Sign)
	err = t.Sign.DeserializeHexStr(tstr.Sign)
	return *t, err
}

// RSASig contains the ID of the signer and the rsa signature.
// while RSA signatures don't necessarily need this storage in the context of CTng,
// this consistency reduces complexity of the code.
type RSASig struct {
	Sig []byte
	ID  CTngID
}

//String -> RSASig conversion
func (s RSASig) String() string {
	return fmt.Sprintf(`{"sig":"%s","id":"%s"}`, hex.EncodeToString(s.Sig), s.ID.String())
}

//RSASig -> String conversion
func RSASigFromString(str string) (RSASig, error) {
	stringmap := make(map[string]string)
	sig := new(RSASig)
	err := json.Unmarshal([]byte(str), &stringmap)
	if err != nil {
		return *sig, err
	}
	sig.Sig = make([]byte, hex.DecodedLen(len(stringmap["sig"])))
	_, err = hex.Decode(sig.Sig, []byte(stringmap["sig"]))
	if err != nil {
		return *sig, err
	}
	sig.ID = CTngID(stringmap["id"])
	return *sig, err
}

// Public key maps for the configuration files.
// Maps a CTngID to its given public key for bls or rsa, respectively..
// Given one of these maps and a ThresholdSig, SigFragment, or RSASig,
// it is always possible to verify the signature.
// This follows the security assumption that "All public keys are known to all parties."
type BlsPublicMap map[CTngID]bls.PublicKey

type RSAPublicMap map[CTngID]rsa.PublicKey

// Serialization of these fields for transportation.
// Note that this is an inconvenience of this specific C-BLS library.
// Normally, we would be able to just Marshal/Unmarshal a mapping,
// but data is lost if we try to do this without serializing Keys.
func (p *BlsPublicMap) Serialize() map[string][]byte {
	serialized := make(map[string][]byte)
	for id, key := range *p {
		serialized[id.String()] = (&key).Serialize()
	}
	return serialized
}

// Deserialize takes the serialized version of the public map, deserializes it, and puts it in p.
// p should be a pre-allocated space for the BLSPublicMap to be stored.
// this can be done with new(BlsPublicMap).
func (p *BlsPublicMap) Deserialize(serialized map[string][]byte) error {
	var err error
	blsPub := new(bls.PublicKey)
	for key, val := range serialized {
		err = blsPub.Deserialize(val)
		if err != nil {
			return err
		}
		(*p)[CTngID(key)] = *blsPub
	}
	return nil
}

// This privatekey map is returned by the key generator. Individual private keys should be
// stored in the crypto configuration file of each entity.
type BlsPrivateMap map[CTngID]bls.SecretKey

// The CryptoConfig is a struct that contains all cryptography details for use in CTng.
// This object has methods associated with it in crypto_config.go, which allow the user to complete
// neccessary cryptographic tasks of ctng.
type CryptoConfig struct {
	Threshold          int            // The threshold for aggregating to a threshold signature.
	N                  int            // The total number of participants of the "threshold network"
	HashScheme         HashAlgorithm  // The hash algorithm to be used for any hashing.
	SignScheme         string         // "rsa" is the only valid value currently.
	ThresholdScheme    string         // "bls" is the only valid value currently.
	SignaturePublicMap RSAPublicMap   // map of entityID to RSA public key
	ThresholdPublicMap BlsPublicMap   // mapping of CTngIds to public keys
	SelfID             CTngID         // id of the current entity
	RSAPrivateKey      rsa.PrivateKey // RSA private key
	ThresholdSecretKey bls.SecretKey  // secret key for the current entity
}

// This is the serialized version of CryptoConfig.
// Again, this is required because we're using the bls C implementation which can't be
// stored without serialization.
type StoredCryptoConfig struct {
	SelfID          CTngID // id of the current entity
	Threshold       int    //f+1 is the threshold for signing
	N               int    //n is the number of participants
	HashScheme      int
	SignScheme      string // "rsa" is the only valid value currently.
	ThresholdScheme string // "bls" is the only valid value currently.
	//entityIDs          []CTngID      // id of each entity (DNS string), should really exist outside of this struct.
	SignaturePublicMap RSAPublicMap      // map of entityID to RSA public key
	RSAPrivateKey      rsa.PrivateKey    // RSA private key
	ThresholdPublicMap map[string][]byte // mapping of BLS IDs to public keys
	ThresholdSecretKey []byte            //
}
